var documenterSearchIndex = {"docs":
[{"location":"readme/","page":"Home","title":"Home","text":"EditURL = \"https://github.com/JuliaTurkuDataScience/MicrobiomeAnalysis.jl/blob/main/README.md\"","category":"page"},{"location":"readme/#MicrobiomeAnalysis.jl","page":"Home","title":"MicrobiomeAnalysis.jl","text":"","category":"section"},{"location":"readme/","page":"Home","title":"Home","text":"(Image: Dev) (Image: CI) (Image: codecov)","category":"page"},{"location":"readme/","page":"Home","title":"Home","text":"This package provides common methods for microbiome analysis based on the SummarizedExperiment and MultiAssayExperiment data containers. This work in Julia language reflects related developments in R.","category":"page"},{"location":"readme/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"readme/","page":"Home","title":"Home","text":"This package has been registered in the Julia General Registry, so it can be installed as follows:","category":"page"},{"location":"readme/","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"MicrobiomeAnalysis\")\nusing MicrobiomeAnalysis","category":"page"},{"location":"readme/","page":"Home","title":"Home","text":"For the latest functionality, you can clone this repo locally and start Julia with:","category":"page"},{"location":"readme/","page":"Home","title":"Home","text":"git clone git@github.com:JuliaTurkuDataScience/MicrobiomeAnalysis.jl.git\ncd McrobiomeAnalysis.jl\njulia --project=.","category":"page"},{"location":"readme/","page":"Home","title":"Home","text":"and then run this in the Julia REPL:","category":"page"},{"location":"readme/","page":"Home","title":"Home","text":"using MicrobiomeAnalysis","category":"page"},{"location":"readme/","page":"Home","title":"Home","text":"Now you should be able to access and use all exported functions, for instance:","category":"page"},{"location":"readme/","page":"Home","title":"Home","text":"shannon\n> shannon (generic function with 3 methods)","category":"page"},{"location":"readme/#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"readme/","page":"Home","title":"Home","text":"Function reference manual\nBasic microbiome workflow examples","category":"page"},{"location":"readme/#Data-containers","page":"Home","title":"Data containers","text":"","category":"section"},{"location":"readme/","page":"Home","title":"Home","text":"MicrobiomeAnalysis.jl supports the analysis based on specific data containers:","category":"page"},{"location":"readme/","page":"Home","title":"Home","text":"MultiAssayExperiments\nSummarizedExperiments","category":"page"},{"location":"readme/#Microbiome-data-analysis-packages","page":"Home","title":"Microbiome data analysis packages","text":"","category":"section"},{"location":"readme/","page":"Home","title":"Home","text":"Simulate microbial community dynamics and time series:","category":"page"},{"location":"readme/","page":"Home","title":"Home","text":"FdeSolver","category":"page"},{"location":"readme/","page":"Home","title":"Home","text":"Independently developed packages for microbiome analysis provide additional utilities but require in some cases further integration with the SE and MAE data containers.","category":"page"},{"location":"readme/","page":"Home","title":"Home","text":"BiobakeryUtils\nEcoBase\nMicrobiome","category":"page"},{"location":"readme/#Suggested-dependencies","page":"Home","title":"Suggested dependencies","text":"","category":"section"},{"location":"readme/","page":"Home","title":"Home","text":"A few optional dependencies are recommended for MicrobiomeAnalysis.jl to function properly:","category":"page"},{"location":"readme/","page":"Home","title":"Home","text":"DataFrames\nDataStructures\nMultivariateStats","category":"page"},{"location":"example4/#Tutorial-4:-Convert-between-SummarizedExperiment-and-CommunityProfile","page":"CommunityProfile conversion","title":"Tutorial 4: Convert between SummarizedExperiment and CommunityProfile","text":"","category":"section"},{"location":"example4/","page":"CommunityProfile conversion","title":"CommunityProfile conversion","text":"Both SummarizedExperiment (SE) and CommunityProfile (CP) containers efficiently integrate microbiome profile data into one comprehensive object, from which information is easy to retrieve and analyse. The former originates from SummarizedExperiments.jl, whereas the latter belongs to the EcoJulia framework, and the way they internally organise the data is slightly divergent. Nevertheless, interoperability and conversion between them is possible.","category":"page"},{"location":"example4/","page":"CommunityProfile conversion","title":"CommunityProfile conversion","text":"using MicrobiomeAnalysis\nusing Microbiome # , SummarizedExperiments\nusing DataFrames, DataStructures","category":"page"},{"location":"example4/#From-CP-to-SE","page":"CommunityProfile conversion","title":"From CP to SE","text":"","category":"section"},{"location":"example4/","page":"CommunityProfile conversion","title":"CommunityProfile conversion","text":"First, a CommunityProfile is created from its building blocks and some metadata about the sampling sites (origin) is added.","category":"page"},{"location":"example4/","page":"CommunityProfile conversion","title":"CommunityProfile conversion","text":"# generate array with sample data\nsamps = MicrobiomeSample.([\"s$i\" for i in 1:10]);\n\n# generate array with feature data\ntaxa = [[Taxon(\"s$i\", :species) for i in 1:10]; [Taxon(\"g$i\", :genus) for i in 1:10]];\n\n# generate matrix with random entries\nmat = rand(20, 10);\n\n# create cp instance\ncomm = CommunityProfile(mat, taxa, samps)\n\n# add some metadata about origin\nfor (sample, value) in zip(1:length(samples(comm)), [\"origin$i\" for i in 1:length(samples(comm))])\n\n    set!(samples(comm)[sample], :origin, value)\n\nend","category":"page"},{"location":"example4/","page":"CommunityProfile conversion","title":"CommunityProfile conversion","text":"Next, the CommunityProfile can be reshaped into a SmmarizedExperiment object by redifining its object type, i.e., SummarizedExperiment(comm::CommunityProfile). This method can also be applied to functional profiles, where GeneFunction instances are found in place of Taxon ones.","category":"page"},{"location":"example4/","page":"CommunityProfile conversion","title":"CommunityProfile conversion","text":"# convert cp to se\nse_converted = SummarizedExperiment(comm)","category":"page"},{"location":"example4/#From-SE-to-CP","page":"CommunityProfile conversion","title":"From SE to CP","text":"","category":"section"},{"location":"example4/","page":"CommunityProfile conversion","title":"CommunityProfile conversion","text":"A SummarizedExperiment object can also be converted into a CommunityProfile. As an example, we will use the se constructed in the first tutorial, which is redefined through CommunityProfile(se::SummarizedExperiment).","category":"page"},{"location":"example4/","page":"CommunityProfile conversion","title":"CommunityProfile conversion","text":"t, Xapp = LVmodel(); # hide\nassays = OrderedDict{String, AbstractArray}(\"sim\" => Xapp); # hide\nrowdata = DataFrame(name = [\"strain$i\" for i in 1:20], genus = [\"g$i\" for i in 1:20], species = [\"s$i\" for i in 1:20]); # hide\ncoldata = DataFrame(name = [\"t$i\" for i in 1:501], condition = rand([\"lake\", \"ocean\", \"river\"], 501), time = 1:501); # hide\nse = SummarizedExperiment(assays, rowdata, coldata); # hide\n# view se\nse\n# convert se to cp\ncomm_converted = CommunityProfile(se)","category":"page"},{"location":"example4/","page":"CommunityProfile conversion","title":"CommunityProfile conversion","text":"It is highly recommended for the conversion to succeed that the rowdata of the original SummarizedExperiment object contains columns named by and specifying at least one of the following:","category":"page"},{"location":"example4/","page":"CommunityProfile conversion","title":"CommunityProfile conversion","text":"strain\nsubspecies\nspecies\ngenus\nphamily\norder\nclass\nphylum\nkingdom","category":"page"},{"location":"example4/#Further-applications","page":"CommunityProfile conversion","title":"Further applications","text":"","category":"section"},{"location":"example4/","page":"CommunityProfile conversion","title":"CommunityProfile conversion","text":"BioBakeryUtils.jl implements MetaPhlAn and HUMAnN ports for the Julia language. Both these workflows return an abundance or gene assay in the form of a CommunityProfile, which can be easily converted into a SummarizedExperiment object. Thus, results from several sources, such as MetaPhlAn and HUMAnN, can be integrated into a single MultiAssayExperiment and analysed in parallel, as explained in tutorial 2.","category":"page"},{"location":"example2/#Tutorial-2:-construct-and-manipulate-a-multiassay-experiment-from-some-simulated-time-series","page":"MAE construction and manipulation","title":"Tutorial 2: construct and manipulate a multiassay experiment from some simulated time series","text":"","category":"section"},{"location":"example2/","page":"MAE construction and manipulation","title":"MAE construction and manipulation","text":"MultiAssayExperiment objects aim to encapsulate and a variety of aspects on the same experimental subject in order to allow cross-investigation at multiple levels. For instance, information on the microbiome, metabolome and biomarkers could be summarised through three separate SummarizedExperiment objects, which are then incorporated in one overall MultiAssayExperiment object.","category":"page"},{"location":"example2/","page":"MAE construction and manipulation","title":"MAE construction and manipulation","text":"using MicrobiomeAnalysis\n# using MultiAssayExperiments, SummarizedExperiments\nusing DataFrames, DataStructures","category":"page"},{"location":"example2/#Simulation","page":"MAE construction and manipulation","title":"Simulation","text":"","category":"section"},{"location":"example2/","page":"MAE construction and manipulation","title":"MAE construction and manipulation","text":"Two time series are generated that simulate an 8-by-5 and a 12-by-6 assays and are meant to represent the microbiome and metabolome data, respectively.","category":"page"},{"location":"example2/","page":"MAE construction and manipulation","title":"MAE construction and manipulation","text":"# evaluate numerical solution for experiment 1\nt1, Xapp1 = LVmodel(8, [0, 12], h = 3);\n# evaluate numerical solution for experiment 2\nt2, Xapp2 = LVmodel(12, [0, 10], h = 2);\nnothing # hide","category":"page"},{"location":"example2/#Summarized-experiments","page":"MAE construction and manipulation","title":"Summarized experiments","text":"","category":"section"},{"location":"example2/","page":"MAE construction and manipulation","title":"MAE construction and manipulation","text":"Made-up information on microbiome taxonomy and sampling site as well as metabolome functionality and sampling wheather are introduced in the corresponding dataframe on features (rowdata) and samples (coldata).","category":"page"},{"location":"example2/","page":"MAE construction and manipulation","title":"MAE construction and manipulation","text":"# convert transposed time series into Dictionary and store it into assays\nassays1 = OrderedDict{String, AbstractArray}(\"foo\" => Xapp1);\nassays2 = OrderedDict{String, AbstractArray}(\"bar\" => Xapp2);\n\n# produce feature data including feature name (because it's required by the\n# SummarizedExperiment function) and information on genus and species\nrowdata1 = DataFrame(\n    name = [\"strain$i\" for i in 1:size(Xapp1, 1)],\n    genus = [\"g$i\" for i in 1:size(Xapp1, 1)],\n    species = [\"s$i\" for i in 1:size(Xapp1, 1)]\n);\n# produce feature data including feature name (because it's required by the\n# SummarizedExperiment function) and information on expression and enzyme\nrowdata2 = DataFrame(\n    name = [\"metabolite$i\" for i in 1:size(Xapp2, 1)],\n    expression = rand([\"intracellular\", \"extracellular\"], size(Xapp2, 1)),\n    enzyme = [\"enzyme$i\" for i in 1:size(Xapp2, 1)]\n);\n\n# produce sample data including sample name (because it's required by the\n# SummarizedExperiment function) and sampling site\ncoldata1 = DataFrame(\n    name = [\"day$i\" for i in 1:size(Xapp1, 2)],\n    origin = rand([\"lake\", \"ocean\", \"river\"], size(Xapp1, 2)),\n    time = t1\n);\n# produce sample data including sample name (because it's required by the\n# SummarizedExperiment function) and wheather conditions\ncoldata2 = DataFrame(\n    name = [\"month$i\" for i in 1:size(Xapp2, 2)],\n    wheather = rand([\"sunny\", \"cloudy\", \"rainy\"], size(Xapp2, 2)),\n    time = t2\n);\nnothing # hide","category":"page"},{"location":"example2/#Multiassay-experiment","page":"MAE construction and manipulation","title":"Multiassay experiment","text":"","category":"section"},{"location":"example2/","page":"MAE construction and manipulation","title":"MAE construction and manipulation","text":"The two assays are then assembled with their respective meta data. In addition, the sample data and the sample map are created and used to make the final MultiAssayExperiment object. The former element provides absolute results or some other kind of overall knowledge concerning all samples from all experiments, whereas the latter systematically maps the sample data to every column of the various experiments.","category":"page"},{"location":"example2/","page":"MAE construction and manipulation","title":"MAE construction and manipulation","text":"# create a dictionary of multiple experiments\nexpo = OrderedDict{String, SummarizedExperiment}();\nexpo[\"microbiome\"] = SummarizedExperiment(assays1, rowdata1, coldata1);\nexpo[\"metabolome\"] = SummarizedExperiment(assays2, rowdata2, coldata2);\n\n# define general sample data that is not inherently present in experiment columns\nsample_data = DataFrame(\n     name = [\"sample$i\" for i in 1:6],\n     state = rand([\"pure\", \"polluted\", \"contaminated\", \"remediated\"], 6)\n);\n\n# define mapping between samples and experiment columns\nsample_map = DataFrame(\n    sample = [\"sample1\", \"sample3\", \"sample3\", \"sample3\", \"sample6\", \"sample5\", \"sample2\", \"sample1\", \"sample4\", \"sample4\", \"sample2\"],\n    experiment = [\"microbiome\", \"metabolome\", \"microbiome\", \"microbiome\", \"metabolome\", \"metabolome\", \"microbiome\", \"metabolome\", \"metabolome\", \"microbiome\", \"metabolome\"],\n    colname = [\"day1\", \"month3\", \"day5\", \"day3\", \"month6\", \"month5\", \"day2\", \"month1\", \"month4\", \"day4\", \"month2\"]\n);\n\n# assemble ingredients into a MultiAssayExperiment object\nmae = MultiAssayExperiment(expo, sample_data, sample_map)","category":"page"},{"location":"example2/#Object-manipulation","page":"MAE construction and manipulation","title":"Object manipulation","text":"","category":"section"},{"location":"example2/","page":"MAE construction and manipulation","title":"MAE construction and manipulation","text":"The resulting mae can be finely retrieved for specific experiments, subsetted by features, samples and assays as well as melted into its building components.","category":"page"},{"location":"example2/","page":"MAE construction and manipulation","title":"MAE construction and manipulation","text":"# extract microbiome experiment from mae, without sample data\nse1 = experiment(mae, \"microbiome\", sampledata = false);\n# extract metabolome experiment from mae, with sample data\nse2 = experiment(mae, \"metabolome\", sampledata = true);\n\n# take a 3-sample subset of mae, keeping all experiments\nsample_subset = multifilter(mae, samples = [\"sample1\", \"sample3\", \"sample3\"]);\n# take a 1-experiment subset of mae, keeping all samples\nexp_subset = multifilter(mae, experiments = \"metabolome\");\n# take a 3-sample 1-experiment subset of mae\nsample_exp_subset = multifilter(mae, experiments = \"metabolome\", samples = [\"sample1\", \"sample3\", \"sample3\"]);\n\n# extract experiments object\nexperiments(mae);\n# extract sample data object\nsampledata(mae);\n# extract sample map object\nsamplemap(mae);\nnothing # hide","category":"page"},{"location":"example3/#Tutorial-3:-Import-data-containers-from-csv-files","page":"SE and MAE retrieval","title":"Tutorial 3: Import data containers from csv files","text":"","category":"section"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"SummarizedExperiment and MultiAssayExperiment containers can be imported from R as a collection of csv files.","category":"page"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"using MicrobiomeAnalysis\n# using MultiAssayExperiments, SummarizedExperiments","category":"page"},{"location":"example3/#Importing-SE","page":"SE and MAE retrieval","title":"Importing SE","text":"","category":"section"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"In this example, the R-native OKeefeDSData dataset is first disassembled into its components, which are saved as csv files. Next, these files are read in Julia and re-assembled into a SummarizedExperiment.","category":"page"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"In R, you can adjust the code below to retrieve the se and split it into three csv files, which contain the assays, the rowdata and the coldata, respectively.","category":"page"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"# R\n\n# load OKeefeDSData container\nlibrary(microbiomeDataSets)\nse <- OKeefeDSData()\n\n# store assays, coldata and rowdata into variables\nassays <- assays(se)\ncoldata <- colData(se)\nrowdata <- rowData(se)\n\n# write out csv files with assays, rowdata and coldata, respectively\nwrite.csv(assays, \"DS_assays.csv\")\nwrite.csv(rowdata, \"DS_rowdata.csv\")\nwrite.csv(coldata,\"DS_coldata.csv\")","category":"page"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"In Julia, it is necessary to pass the paths to the three files to the import_se_from_csv function, keeping in mind the correct order.","category":"page"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"# Julia\n\n# assemble se from csv files\nimport_se_from_csv(\"DS_assays.csv\",\n                   \"DS_rowdata.csv\",\n                   \"DS_coldata.csv\")","category":"page"},{"location":"example3/#Importing-MAE","page":"SE and MAE retrieval","title":"Importing MAE","text":"","category":"section"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"Similarly, the HintikkaXOData container can be exported from R to Julia as an analogous MultiAssayExperiment object.","category":"page"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"This time, the container needs to be divided into one assay file for each experiment within the mae. That is, if a mae contains three experiments, such as HintikkaXOData, then three different assay files need to be generated. In addition, the sample data and the sample map also go to make one csv file each.","category":"page"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"# R\n\n# load HintikkaXOData container\nlibrary(microbiomeDataSets)\nmae <- HintikkaXOData()\n\n# split mae into se elements\nse1 <- mae[[\"microbiota\"]]\nse2 <- mae[[\"metabolites\"]]\nse3 <- mae[[\"biomarkers\"]]\n\n# store assays of respective se into variables\nmicrobiota_assays <- assays(se1)\nmetabolites_assays <- assays(se2)\nbiomarkers_assays <- assays(se3)\n\n# write out csv files with assays\nwrite.csv(microbiota_assays, \"XO_microbiota_assays.csv\")\nwrite.csv(metabolites_assays, \"XO_metabolites_assays.csv\")\nwrite.csv(biomarkers_assays, \"XO_biomarkers_assays.csv\")\n\n# write out csv files with sample data and sample map, respectively\nwrite.csv(colData(mae), \"XO_sample_data.csv\")\nwrite.csv(sampleMap(mae),\"XO_sample_map.csv\",\n          row.names = FALSE)","category":"page"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"As in the previous case, the csv files are re-assembled into a mae in Julia. The paths to the assay files should be provided to import_mae_from_csv as a list in the first argument, followed by sample data and sample map file paths. Also, the optional argument experiment_names lets you choose custom names for the experiments.","category":"page"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"# Julia\n\n# make a list with the paths to the assays files\nexperiment_files = [\"XO_microbiota_assays.csv\",\n                    \"XO_metabolites_assays.csv\",\n                    \"XO_biomarkers_assays.csv\"]\n\n# make a list with custom names for the experiments\nexperiment_names = [\"microbiota\", \"metabolites\", \"biomarkers\"]\n\n# assemble mae from csv files\nmae = import_mae_from_csv(experiment_files,\n                          \"XO_sample_data.csv\",\n                          \"XO_sample_map.csv\",\n                          experiment_names = experiment_names)","category":"page"},{"location":"example3/#Retrieval-of-readily-available-datasets","page":"SE and MAE retrieval","title":"Retrieval of readily available datasets","text":"","category":"section"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"It is also possible to get started with a ready-made experiment and try to perform analysis on it. The following studies come pre-installed with this package:","category":"page"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"HintikkaXOData\nOKeefeDSData","category":"page"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"In order to retrieve a specific experiment, a function with the same name is called. This returns the experiment itself, which can be stored into a variable and investigated further.","category":"page"},{"location":"example3/","page":"SE and MAE retrieval","title":"SE and MAE retrieval","text":"mae = HintikkaXOData()","category":"page"},{"location":"example1/#Tutorial-1:-construct-and-analyse-a-summarized-experiment-from-a-simulated-time-series","page":"SE construction and analysis","title":"Tutorial 1: construct and analyse a summarized experiment from a simulated time series","text":"","category":"section"},{"location":"example1/","page":"SE construction and analysis","title":"SE construction and analysis","text":"This example walks you through the microdiversity analysis of a time series that simulates a Lotka-Volterra community with 20 strains and 500 time points.","category":"page"},{"location":"example1/","page":"SE construction and analysis","title":"SE construction and analysis","text":"using MicrobiomeAnalysis # , SummarizedExperiments\nusing DataFrames, DataStructures\nusing Plots, MultivariateStats","category":"page"},{"location":"example1/#Simulation","page":"SE construction and analysis","title":"Simulation","text":"","category":"section"},{"location":"example1/","page":"SE construction and analysis","title":"SE construction and analysis","text":"Real as well as simulated OTU tables or time series can be stored in a SummarizedExperiment object. In this example, a time series is generated with the function LVmodel, which runs a Lotka-Volterra model by means of FdeSolver.jl. To achieve more control over the simulation, it is possible to produce custom models by directly using the FDEsolver function from the aforementioned package (see a few examples).","category":"page"},{"location":"example1/","page":"SE construction and analysis","title":"SE construction and analysis","text":"# evaluate numerical solution\nt, Xapp = LVmodel();\nnothing # hide","category":"page"},{"location":"example1/#Summarized-Experiment","page":"SE construction and analysis","title":"Summarized Experiment","text":"","category":"section"},{"location":"example1/","page":"SE construction and analysis","title":"SE construction and analysis","text":"Next, the assay produced through LVmodel is combined with the meta data on samples or time steps (coldata) and that on features or species (rowdata) into a SummarizedExperiment object.","category":"page"},{"location":"example1/","page":"SE construction and analysis","title":"SE construction and analysis","text":"# convert transposed time series into Dictionary and store it into assays\nassays = OrderedDict{String, AbstractArray}(\"sim\" => Xapp);\n\n# produce feature data including feature name (because it's required by the\n# SummarizedExperiment function) and information on genus and species\nrowdata = DataFrame(\n    name = [\"strain$i\" for i in 1:20],\n    genus = [\"g$i\" for i in 1:20],\n    species = [\"s$i\" for i in 1:20]\n);\n\n# produce sample data including sample name (because it's required by the\n# SummarizedExperiment function) and sampling site\ncoldata = DataFrame(\n    name = [\"t$i\" for i in 1:501],\n    condition = rand([\"lake\", \"ocean\", \"river\"], 501),\n    time = 1:501\n);\n\n# create SummarizedExperiment object\nse = SummarizedExperiment(assays, rowdata, coldata);\nnothing # hide","category":"page"},{"location":"example1/#α-diversity","page":"SE construction and analysis","title":"α diversity","text":"","category":"section"},{"location":"example1/","page":"SE construction and analysis","title":"SE construction and analysis","text":"Alpha diversity is then estimated with two different metrics (shannon and ginisimpson indices).","category":"page"},{"location":"example1/","page":"SE construction and analysis","title":"SE construction and analysis","text":"# estimate shannon diversity index\nshannon_output = shannon(se, \"sim\");\n# estimate ginisimpson diversity index\nginisimpson_output = ginisimpson(se, \"sim\");\n# estimate and store shannon diversity index into se\nshannon!(se, \"sim\");\n# estimate and store ginisimpson diversity index into se\nginisimpson!(se, \"sim\");\nnothing # hide","category":"page"},{"location":"example1/#β-diversity","page":"SE construction and analysis","title":"β diversity","text":"","category":"section"},{"location":"example1/","page":"SE construction and analysis","title":"SE construction and analysis","text":"Finally, a few dissimilarity metrics for beta diversity are evaluated and the Jaccard index is used to run a Principal Coordinate Analysis across 4 dimensions, which is then visualised on a scatter plot.","category":"page"},{"location":"example1/","page":"SE construction and analysis","title":"SE construction and analysis","text":"# evaluate braycurtis dissimilarity index\nbraycurtis_output = braycurtis(se, \"sim\");\n# evaluate jaccard dissimilarity index\njaccard_output = jaccard(se, \"sim\");\n# evaluate hellinger dissimilarity index\nhellinger_output = hellinger(se, \"sim\");\n\n# run pcoa across 4 dimensions with jaccard dissimilarity\npcoa_model = pcoa(se, \"sim\", dist = jaccard, dim_number = 4);\npcoa_output = predict(pcoa_model);\n\n# prepare colour labels for scatter plot according to sample origin\nx_labels = se.coldata.condition;\nlake = pcoa_output[:, x_labels .== \"lake\"];\nriver = pcoa_output[:, x_labels .== \"river\"];\nocean = pcoa_output[:, x_labels .== \"ocean\"];\n\n# plot pcoa\np1 = scatter(lake[1, :], lake[2, :], lake[4, :]);\nscatter!(river[1, :], river[2, :], river[4, :]);\nscatter!(ocean[1, :], ocean[2, :], ocean[4, :]);\nsavefig(\"plot1.png\"); nothing # hide","category":"page"},{"location":"example1/","page":"SE construction and analysis","title":"SE construction and analysis","text":"(Image: plot1)","category":"page"},{"location":"example1/#Abundance-vs-time-plot","page":"SE construction and analysis","title":"Abundance vs time plot","text":"","category":"section"},{"location":"example1/","page":"SE construction and analysis","title":"SE construction and analysis","text":"Below is a possible method to plot the abundance of each strain throughout the time series.","category":"page"},{"location":"example1/","page":"SE construction and analysis","title":"SE construction and analysis","text":"p2 = abundance_plot(se, \"sim\")\nsavefig(\"plot2.png\"); nothing # hide","category":"page"},{"location":"example1/","page":"SE construction and analysis","title":"SE construction and analysis","text":"(Image: plot2)","category":"page"},{"location":"#API","page":"Manual","title":"API","text":"","category":"section"},{"location":"#Package-features","page":"Manual","title":"Package features","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"functions and workflows for the analysis of microbiome data\nready-to-use example datasets","category":"page"},{"location":"#Utility-documentation","page":"Manual","title":"Utility documentation","text":"","category":"section"},{"location":"#α-diversity","page":"Manual","title":"α diversity","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"shannon\nshannon!\nginisimpson\nginisimpson!","category":"page"},{"location":"#Microbiome.shannon","page":"Manual","title":"Microbiome.shannon","text":"shannon(se::SummarizedExperiment, assay_name::String)\n\nEvaluates the shannon diversity index for each sample and returns it as a vector.\n\nArguments\n\nse::SummarizedExperiment: the experiment object of interest.\nassay_name::String: the name of the assay to base the evaluation on.\n\n\n\n\n\n","category":"function"},{"location":"#Microbiome.shannon!","page":"Manual","title":"Microbiome.shannon!","text":"shannon!(se::SummarizedExperiment, assay_name::String)\n\nEvaluates the shannon diversity index for each sample and stores it into coldata(se).\n\nArguments\n\nse::SummarizedExperiment: the experiment object of interest.\nassay_name::String: the name of the assay to base the evaluation on.\n\n\n\n\n\n","category":"function"},{"location":"#Microbiome.ginisimpson","page":"Manual","title":"Microbiome.ginisimpson","text":"ginisimpson(se::SummarizedExperiment, assay_name::String)\n\nEvaluates the ginisimpson diversity index for each sample and returns it as a vector.\n\nArguments\n\nse::SummarizedExperiment: the experiment object of interest.\nassay_name::String: the name of the assay to base the evaluation on.\n\n\n\n\n\n","category":"function"},{"location":"#Microbiome.ginisimpson!","page":"Manual","title":"Microbiome.ginisimpson!","text":"ginisimpson!(se::SummarizedExperiment, assay_name::String)\n\nEvaluates the ginisimpson diversity index for each sample and stores it into coldata(se).\n\nArguments\n\nse::SummarizedExperiment: the experiment object of interest.\nassay_name::String: the name of the assay to base the evaluation on.\n\n\n\n\n\n","category":"function"},{"location":"#β-diversity","page":"Manual","title":"β diversity","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"braycurtis\njaccard\nhellinger\npcoa","category":"page"},{"location":"#Microbiome.braycurtis","page":"Manual","title":"Microbiome.braycurtis","text":"braycurtis(se::SummarizedExperiment, assay_name::String)\n\nEvaluates the braycurtis dissimilarity index for each sample and rturns it as a matrix.\n\nArguments\n\nse::SummarizedExperiment: the experiment object of interest.\nassay_name::String: the name of the assay to base the evaluation on.\n\n\n\n\n\n","category":"function"},{"location":"#Microbiome.jaccard","page":"Manual","title":"Microbiome.jaccard","text":"jaccard(se::SummarizedExperiment, assay_name::String)\n\nEvaluates the jaccard dissimilarity index for each sample and rturns it as a matrix.\n\nArguments\n\nse::SummarizedExperiment: the experiment object of interest.\nassay_name::String: the name of the assay to base the evaluation on.\n\n\n\n\n\n","category":"function"},{"location":"#Microbiome.hellinger","page":"Manual","title":"Microbiome.hellinger","text":"hellinger(se::SummarizedExperiment, assay_name::String)\n\nEvaluates the hellinger dissimilarity index for each sample and rturns it as a matrix.\n\nArguments\n\nse::SummarizedExperiment: the experiment object of interest.\nassay_name::String: the name of the assay to base the evaluation on.\n\n\n\n\n\n","category":"function"},{"location":"#Microbiome.pcoa","page":"Manual","title":"Microbiome.pcoa","text":"pcoa(se::SummarizedExperiment, assay_name::String)\n\nRuns a Multidimensional Scaling (MDS) for the selected assay of se and returns a model that can be executed with predict(model).\n\nArguments\n\nse::SummarizedExperiment: the experiment object of interest.\nassay_name::String: the name of the assay to base the evaluation on.\n\n\n\n\n\n","category":"function"},{"location":"#Modelling-and-Simulations","page":"Manual","title":"Modelling and Simulations","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"LVmodel","category":"page"},{"location":"#MicrobiomeAnalysis.LVmodel","page":"Manual","title":"MicrobiomeAnalysis.LVmodel","text":"LVmodel(N::Int64 = 20, tSpan::Vector{<:Real} = [0, 50]; β = 1, h = 0.1, random = false)\n\nGenerates a Lotka-Volterra model for N species over the given time span. The output is a time series of abundance values that can be stored as two separate objects: t, Xapp = LVmodel()\n\nArguments\n\nN::Int64: the size of the model community, that is, the number of species in the system.\ntSpan::Vector{<:Real}: the time span along which computation is performed.\nβ::Real: the order of derivation for all the differential equations of the LV model.\nh::Real: the step size for correction.\nrandom::Bool: whether the function should return a randomised (true) or constant (false) model.\n\n\n\n\n\n","category":"function"},{"location":"#Assay-Transformation","page":"Manual","title":"Assay Transformation","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"transform\ntransform!","category":"page"},{"location":"#DataFrames.transform","page":"Manual","title":"DataFrames.transform","text":"transform(se::SummarizedExperiment, assay_name::String, method::Function, kwargs...)\n\nApplies a transformation to a given assay and returns it as a Matrix{<:Real} object.\n\nArguments\n\nse::SummarizedExperiment: the experiment object of interest.\nassay_name::String: the name of the assay to base the evaluation on.\nmethod::Function: the transformation to apply. It can entail the following values: log10, pa, ztransform, clr.\nkwargs...: additional parameters specific to some methods.\n\n\n\n\n\n","category":"function"},{"location":"#DataFrames.transform!","page":"Manual","title":"DataFrames.transform!","text":"transform(se::SummarizedExperiment, assay_name::String, method::Function, kwargs...; output_name::String = \"transformed_\" * assay_name)\n\nApplies a transformation to a given assay and stores it into se as a new assay.\n\nArguments\n\nse::SummarizedExperiment: the experiment object of interest.\nassay_name::String: the name of the assay to base the evaluation on.\nmethod::Function: the transformation to apply. It can entail the following values: log10, pa, ztransform, clr.\nkwargs...: additional parameters specific to some methods.\noutput_name::String: custom name for the newly created assay.\n\n\n\n\n\n","category":"function"},{"location":"#Sorting-by-top-taxa","page":"Manual","title":"Sorting by top taxa","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"select_top_taxa","category":"page"},{"location":"#MicrobiomeAnalysis.select_top_taxa","page":"Manual","title":"MicrobiomeAnalysis.select_top_taxa","text":"select_top_taxa(se::SummarizedExperiment, assay_name::String; top_n::Int64 = 10, sel_method::Function = mean)\n\nSorts rows / features by one specific assay and returns the top elements.\n\nArguments\n\nse::SummarizedExperiment: the experiment object of interest.\nassay_name::String: the name of the assay to base the evaluation on.\ntop_n::Int64: the number of top elements that are returned.\nsel_method::Function: statistical measure to perform sorting (mean by default).\n\n\n\n\n\nselect_top_taxa(se::SummarizedExperiment, assay_names::Vector{String}; top_n::Int64 = 10, sel_method::Function = mean)\n\nSorts rows / features by multiple assays and returns the top elements.\n\nArguments\n\nse::SummarizedExperiment: the experiment object of interest.\nassay_names::Vector{String}: a vector of multiple assay names to base the evaluation on.\ntop_n::Int64: the number of top elements that are returned.\nsel_method::Function: statistical measure to perform sorting (mean by default).\n\n\n\n\n\n","category":"function"},{"location":"#Visualisation","page":"Manual","title":"Visualisation","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"abundance_plot","category":"page"},{"location":"#MicrobiomeAnalysis.abundance_plot","page":"Manual","title":"MicrobiomeAnalysis.abundance_plot","text":"abundance_plot(se::SummarizedExperiment, assay_name::String)\n\nPlots a time series of the abundance for each feature (row) of an assay in a SummarizedExperiment object. The corresponding should include a column named 'time' containing an array of sampling times\n\nArguments\n\nse::SummarizedExperiment: the experiment object of interest.\nassay_name::String: the name of the assay to base the visualisation on.\n\n\n\n\n\n","category":"function"},{"location":"#Importing-Datasets","page":"Manual","title":"Importing Datasets","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"HintikkaXOData\nOKeefeDSData\nimport_se_from_csv\nimport_mae_from_csv\nSummarizedExperiment\nCommunityProfile","category":"page"},{"location":"#MicrobiomeAnalysis.HintikkaXOData","page":"Manual","title":"MicrobiomeAnalysis.HintikkaXOData","text":"HintikkaXOData()\n\nRetrieves the HintikkaXO MultiAssayExperiment, consisting of the microbiota, metabolite and biomarker SummarizedExperiment data, by Hintikka et al. (2021), https://doi.org/10.3390/ijerph18084049.\n\n\n\n\n\n","category":"function"},{"location":"#MicrobiomeAnalysis.OKeefeDSData","page":"Manual","title":"MicrobiomeAnalysis.OKeefeDSData","text":"OKeefeDSData()\n\nRetrieves the OKeefeDS SummarizedExperiment, consisting of the microbiota, contains microbiome data from a study with African and African American groups undergoing a two-week diet swap, by O'Keefe et al. (2015), https://dx.doi.org/10.1038/ncomms7342.\n\n\n\n\n\n","category":"function"},{"location":"#MicrobiomeAnalysis.import_se_from_csv","page":"Manual","title":"MicrobiomeAnalysis.import_se_from_csv","text":"import_se_from_csv(assays_file::AbstractString, rowdata_file::AbstractString, coldata_file::AbstractString)\n\nImports a SummarizedExperiment object from its components stored as csv files.\n\nArguments\n\nassays_file::AbstractString: the path to a csv file containing the assays.  It is produced in R with write.csv(assays(se), \"assays_file.csv\").\nrowdata_file::AbstractString: the path to a csv file containing the rowdata.  It is produced in R with write.csv(rowData(se), \"rowdata_file.csv\").\ncoldata_file::AbstractString: the path to a csv file containing the coldata.  It is produced in R with write.csv(colData(se), \"coldata_file.csv\").\n\n\n\n\n\nimport_se_from_csv(assays_file::AbstractString)\n\nImports a SummarizedExperiment object from a csv file containing the assays. Rowdata and coldata are generated based on the information stored in the row and column names of assays_file. This is the method of choice if the rowdata and coldata of the original SummarizedExperiment object does not provide valuable information either because they are empty or because they are part of a MultiAssayExperiment object.\n\nArguments\n\nassays_file::AbstractString: the path to a csv file containing the assays.  It is produced in R with write.csv(assays(se), \"assays_file.csv\").\n\n\n\n\n\n","category":"function"},{"location":"#MicrobiomeAnalysis.import_mae_from_csv","page":"Manual","title":"MicrobiomeAnalysis.import_mae_from_csv","text":"import_mae_from_csv(experiment_files::Vector{<:AbstractString}, sample_data_file::AbstractString, sample_map_file::AbstractString; experiment_names::Vector{<:AbstractString} = experiment_files)\n\nImports a MultiAssayExperiment object from its components stored as csv files.\n\nArguments\n\nexperiment_files::Vector{<:AbstractString}: a list of paths to the csv files  containing the assays of different experiments. For example, if a MultiAssayExperiment  object has 3 experiments, experiment_files is defined as: [assays_file1, assays_file2, assays_file3]  Each assays_file is produced in R with write.csv(assays(se), \"assays_file.csv\").  It is produced in R with write.csv(assays(se), \"assays_file.csv\").\nsample_data_file::AbstractString: the path to a csv file containing the sample data.  It is produced in R with write.csv(colData(mae), \"sample_data_file.csv\").\nsample_map_file::AbstractString: the path to a csv file containing the sample map.  It is produced in R with write.csv(colData(mae), \"sample_map_file.csv\", row.names = FALSE).\nexperiment_names::Vector{<:AbstractString}: a vector of names to assign to the  experiments listed in experiment_files. By default, the experiments are named  with the filepaths specified in experiment_files.\n\n\n\n\n\n","category":"function"},{"location":"#SummarizedExperiments.SummarizedExperiment","page":"Manual","title":"SummarizedExperiments.SummarizedExperiment","text":"SummarizedExperiment(comm::CommunityProfile)\n\nConverts a CommunityProfile to a SummarizedExperiment object.\n\nArguments\n\ncomm::CommunityProfile: the CommunityProfile to be converted.\n\n\n\n\n\n","category":"type"},{"location":"#Microbiome.CommunityProfile","page":"Manual","title":"Microbiome.CommunityProfile","text":"CommunityProfile(se::SummarizedExperiment)\n\nConverts a SummarizedExperiment object to a CommunityProfile.\n\nArguments\n\nse::SummarizedExperiment: the SummarizedExperiment object to be converted.\n\n\n\n\n\n","category":"type"}]
}
